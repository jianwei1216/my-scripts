#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include "erasure_code.h"

#ifndef RANDOMS
#define RANDOMS 201
#endif

#ifndef INTEL_MMATRIX_LEN
#define INTEL_MMATRIX_LEN 5
#endif

#ifndef INTEL_KMATRIX_LEN
#define INTEL_KMATRIX_LEN 3
#endif

#ifndef INTEL_SEED
#define INTEL_SEED 11
#endif

#define MMAX INTEL_MMATRIX_LEN
#define KMAX INTEL_KMATRIX_LEN

#define alloca0(size) ({void *__ptr; __ptr = alloca(size); memset(__ptr, 0, size); __ptr; })

#define NO_INVERT_MATRIX -2

#define char_show(error_count, str, max_count, nerrs, nsrcerrs) do { \
    int i;                                         \
    printf ("%d==>\t", error_count);                 \
    for (i = 0; i < max_count; i++) {              \
       printf ("%d\t", str[i]);                    \
    }                                              \
    printf ("nerrs=%d, nsrcerrs=%d\n",nerrs, nsrcerrs);\
} while(0)

#define char_init(src, max_count) do {   \
    int i;                                      \
    for (i = 0; i < max_count; i++) {           \
        src[i] = 0;                    \
    }                                           \
} while(0)

#define INIT_LIST_HEAD(head) do {               \
        (head)->next = (head)->prev = head;     \
    } while (0)

struct list_head {
	struct list_head *next;
	struct list_head *prev;
};

typedef struct {
    struct list_head list;
    char *src_in_err;
    char *src_err_list;
    unsigned char *decode_matrix;
    unsigned char *decode_tbls;
    unsigned int  *decode_index;
    int nerrs;
    int nsrcerrs;
    int m;
    int k;
} ec_decode_matrix_t;

static unsigned char *encode_matrix, *encode_tbls;
static struct list_head decode_list_head;
static int decode_list_count = 0;

static inline void
list_add (struct list_head *new, struct list_head *head)
{
    new->prev = head;
    new->next = head->next;

    new->prev->next = new;
    new->next->prev = new;
}

int ec_method_initialize_intel (const int m, const int k)
{
    int ret = -1;

    srand (INTEL_SEED);  

	encode_matrix = calloc (m * k, sizeof(*encode_matrix));
	encode_tbls   = calloc (m * k * 32, sizeof(*encode_tbls));
    if (!encode_matrix || !encode_tbls) {
        printf ("Failed to allocate "
                "memory for encode_matrix and encode_tbls!\n");
        goto out;
    }

    /*
	 * Generate encode matrix encode_matrix
	 * The matrix generated by gf_gen_cauchy1_matrix
	 * is always invertable.
     */
	gf_gen_cauchy1_matrix (encode_matrix, m, k);

    /* Generate g_tbls from encode matrix encode_matrix */
    ec_init_tables (k, m - k, &encode_matrix[k * k], encode_tbls);

    INIT_LIST_HEAD (&decode_list_head);

    ret = 0;

out:
    if (ret) {
        if (encode_matrix)
            free (encode_matrix);
        if (encode_tbls)
            free (encode_tbls);
    }

    return ret;
}

static int gf_gen_decode_matrix(unsigned char *encode_matrix,
				                unsigned char *decode_matrix,
				                unsigned char *invert_matrix,
				                unsigned int *decode_index,
				                unsigned char *src_err_list,
				                unsigned char *src_in_err,
				                int nerrs, int nsrcerrs, int k, int m)
{
	int             i       = 0;
    int             j       = 0;
    int             p       = 0;
	int             r       = 0;
	int             incr    = 0;
    unsigned char   s       = 0;
	unsigned char   *backup = NULL;
    unsigned char   *b      = NULL;

	b      = calloc (m * k, sizeof(*b));
	backup = calloc (m * k, sizeof(*backup));
	if (b == NULL || backup == NULL) {
        printf ("Failed to allocate "
                "memory for matrix!\n");
        if (b)
		    free (b);
        if (backup)
		    free (backup);
		return -1;
	}

	/* Construct matrix b by removing error rows */
	for (i = 0, r = 0; i < k; i++, r++) {
		while (src_in_err[r])
			r++;
		for (j = 0; j < k; j++) {
			b[k * i + j] = encode_matrix[k * r + j];
			backup[k * i + j] = encode_matrix[k * r + j];
		}
		decode_index[i] = r;
	}

	incr = 0;
	while (gf_invert_matrix(b, invert_matrix, k) < 0) {
		if (nerrs == (m - k)) {
            if (b)
                free (b);
            if (backup)
                free (backup);
            printf ("%d:BAD MATRIX!\n", __LINE__);
			return NO_INVERT_MATRIX;
		}
		incr++;
		memcpy(b, backup, MMAX * KMAX);
		for (i = nsrcerrs; i < nerrs - nsrcerrs; i++) {
			if (src_err_list[i] == (decode_index[k - 1] + incr)) {
				// skip the erased parity line
				incr++;
				continue;
			}
		}
		if (decode_index[k - 1] + incr >= m) {
            if (b)
                free (b);
            if (backup)
                free (backup);
            printf ("%d:BAD MATRIX!\n", __LINE__);
			return NO_INVERT_MATRIX;
		}
		decode_index[k - 1] += incr;
		for (j = 0; j < k; j++)
			b[k * (k - 1) + j] = encode_matrix[k * decode_index[k - 1] + j];
	}

	for (i = 0; i < nsrcerrs; i++) {
		for (j = 0; j < k; j++) {
			decode_matrix[k * i + j] = invert_matrix[k * src_err_list[i] + j];
		}
	}

	/* src_err_list from encode_matrix * invert of b for parity decoding */
	for (p = nsrcerrs; p < nerrs; p++) {
		for (i = 0; i < k; i++) {
			s = 0;
			for (j = 0; j < k; j++)
				s ^= gf_mul(invert_matrix[j * k + i],
					        encode_matrix[k * src_err_list[p] + j]);

			decode_matrix[k * p + i] = s;
		}
	}

    if (b)
        free (b);
    if (backup)
        free (backup);

	return 0;
}

static long long ec_method_combination (const int m, const int k)
{
    long long ret = -EINVAL;
    unsigned long long redundancy = 0;
    unsigned long long sum = 0;
    unsigned long long i = 0;
    unsigned long long j = 0;
    unsigned long long n1 = 1;
    unsigned long long m1 = 1;
    unsigned long long n1_m1 = 1;

    if (m <=0 || k <=0) {
        ret = -EINVAL;
        printf ("%d: %s\n", __LINE__, strerror(EINVAL));
        goto out;
    }

    redundancy = m - k;

    for (j = m; j >= 1; j--) {
        n1 *= j;
    }

    for (i = 1; i <= redundancy; i++) {
        m1 = 1;
        n1_m1 = 1;

        for (j = i; j >= 1; j--) {
            m1 *= j;
        }

        for (j = m - i; j >= 1; j--) {
            n1_m1 *= j;
        }

        sum += n1 / (m1 * n1_m1);
    }
    printf ("DEBUG: sum=%d\n", sum);
    ret = sum;
out:
    return ret;
}

static int ec_decode_matrix_new (const int m, const int k,
                                 unsigned char *src_in_err,
                                 unsigned char *src_err_list,
                                 const int nerrs, const int nsrcerrs)
{
    int err = -EINVAL;
    unsigned char *invert_matrix = NULL;
    ec_decode_matrix_t *new = NULL;

    /*char_show (8, src_in_err, m, nerrs, nsrcerrs);*/
    /*char_show (7, src_err_list, m);*/
    
    if (m <= 0 || k <= 0 || src_in_err == NULL
            || src_err_list == NULL
            || nerrs < 0 || nsrcerrs < 0) {
        err = -EINVAL;
        printf ("%d: %s (args: m=%d, k=%d,"\
                "src_in_err=%p, src_err_list=%p, nerrs=%d, nsrcerrs=%d)\n",
                __LINE__, strerror(-err), m, k, src_in_err, src_err_list,
                nerrs, nsrcerrs);
        goto out;
    }

    new = calloc (1, sizeof(*new));
    invert_matrix = calloc (m * k, sizeof(*new));
    if (new== NULL || invert_matrix == NULL) {
        err = -ENOMEM;
        printf ("%s\n", strerror(-err));
        goto out;
    }

    new->src_in_err = calloc (m, sizeof(*(new->src_in_err)));
    new->src_err_list = calloc (m, sizeof(*(new->src_err_list)));
    new->decode_index = calloc (m, sizeof(*(new->decode_index)));
    new->decode_matrix = calloc (m * k, sizeof(*(new->decode_matrix)));
    new->decode_tbls = calloc (m * k * 32, sizeof(*(new->decode_tbls)));
    if (new->src_in_err == NULL
            || new->src_err_list == NULL
            || new->decode_index == NULL
            || new->decode_matrix == NULL
            || new->decode_tbls == NULL) {
        err = -ENOMEM;
        printf ("%s\n", strerror(-err));
        goto out;
    }

    INIT_LIST_HEAD (&new->list);
    new->nerrs = nerrs;
    new->nsrcerrs = nsrcerrs;
    new->m = m;
    new->k = k;
    memcpy (new->src_in_err, src_in_err, m);
    memcpy (new->src_err_list, src_err_list, m);

	err = gf_gen_decode_matrix(encode_matrix, new->decode_matrix,
				               invert_matrix, new->decode_index,
                               src_err_list, src_in_err,
				               nerrs, nsrcerrs, k, m);
	if (err != 0) {
        err = -EIO;
        printf ("Failed to gf_gen_decode_matrix()\n");
        goto out;
	}

	ec_init_tables (k, nerrs, new->decode_matrix, new->decode_tbls);

    list_add (&new->list, &decode_list_head);
    decode_list_count += 1;

    err = 0;

out:
    if (err && new) {
        if (new->src_in_err)
            free (new->src_in_err);
        if (new->src_err_list)
            free (new->src_err_list);
        if (new->decode_index)
            free (new->decode_index);
        if (new->decode_matrix)
            free (new->decode_matrix);
        if (new->decode_tbls)
            free (new->decode_tbls);
        free (new);
    }
    if (invert_matrix)
        free (invert_matrix);

    return err;
}

static int ec_method_decode_matrix_ftw (int n, int m, int k, int *count, int error_count,
                                        unsigned char *src_in_err,
                                        unsigned char *src_err_list,
                                        int *nerrs, int *nsrcerrs)
{
    int i = 0;
    int j = 0;
    int err = -EINVAL;

    for (i = n + 1; i < m; i++) {
        (*count)++;
        src_in_err[i] = 1;
        src_err_list[(*nerrs)++] = i;
        if (i < k)
            (*nsrcerrs)++;

        if ((*count) == error_count) {
            if (*nsrcerrs != 0) {
                err = ec_decode_matrix_new (m, k, src_in_err, src_err_list,
                                            *nerrs, *nsrcerrs);
                if (err < 0) {
                    printf ("%s\n", strerror(-err));
                    goto out;
                }
            }
            char_show(*count, src_in_err, m, *nerrs, *nsrcerrs);
            /*char_show (9, src_err_list, m, *nerrs, *nsrcerrs);*/
            src_in_err[i] = 0;
            (*count)--;
            src_err_list[--(*nerrs)] = 0;
            if (i < k)
                (*nsrcerrs)--;
            continue;
        } else {
            ec_method_decode_matrix_ftw (i, m, k, count, error_count,
                                        src_in_err, src_err_list,
                                        nerrs, nsrcerrs);
            src_in_err[i] = 0;
            (*count)--;
            src_err_list[--(*nerrs)] = 0;
            if (i < k)
                (*nsrcerrs)--;
        }
    }

out:
    return err;
}

static int ec_method_decode_matrix_init (const int m, const int k)
{
    int err = -ENOMEM;
    int i = 0;
    int j = 0;
    int n = 0;
    unsigned char *decode_matrix = NULL;
    unsigned char *invert_matrix = NULL;
    unsigned char *decode_tbls = NULL;
    unsigned char *src_in_err = NULL;
    unsigned char *src_err_list = NULL;
    int nerrs = 0;
    int nsrcerrs = 0;
    unsigned long long decode_matrix_count = 0;
    int redundancy = 0;
    int error_count = 0;
    int tmp_count = 0;
    int *tmp_index = NULL;

    if (m <= 0 || k <= 0) {
        err = -EINVAL;
        printf ("%d: %s", __LINE__, strerror(EINVAL));
        goto out;
    }

    decode_matrix_count = ec_method_combination (m, k);
    if (decode_matrix_count < 0) {
        err = decode_matrix_count;
        printf ("%s\n", strerror(-decode_matrix_count));
        goto out;
    }

    src_in_err = alloca0 (m);
    src_err_list = alloca0 (m);
    char_init(src_in_err, m);
    char_init(src_err_list, m);

    redundancy = m - k;
    error_count = 1;
    tmp_index = calloc (redundancy, sizeof(*tmp_index));
    if (tmp_index == NULL) {
        err = -errno;
        printf ("%s\n", strerror(-err));
        goto out;
    }

    while (error_count <= redundancy) {
        printf ("error_count=%d, redundancy=%d\n", error_count, redundancy);

        for (n = 0; n < m; n++) {
            tmp_count = 0;
            nerrs = 0;
            nsrcerrs = 0;
            char_init(src_in_err, m);
            char_init(src_err_list, m);
            tmp_count++;
            src_in_err[n] = 1;
            src_err_list[nerrs++] = n;
            if (n < k)
                nsrcerrs++;

            if (tmp_count == error_count) {
                char_show (error_count, src_in_err, m, nerrs, nsrcerrs);
                /*char_show (9, src_err_list, m, nerrs, nsrcerrs);*/
                if (nsrcerrs != 0) {
                    err = ec_decode_matrix_new (m, k, src_in_err, src_err_list,
                                                nerrs, nsrcerrs);
                    if (err < 0) {
                        printf ("%s\n", strerror(-err));
                        goto out;
                    }
                }
                src_in_err[n] = 0;
                tmp_count--;
                src_err_list[--nerrs] = 0; 
                if (n < k)
                    nsrcerrs--;
            } else {
                ec_method_decode_matrix_ftw(n, m, k, &tmp_count, error_count,
                                            src_in_err, src_err_list,
                                            &nerrs, &nsrcerrs);
                src_in_err[n] = 0;
                tmp_count--;
                src_err_list[--nerrs] = 0;
                if (n < k)
                    nsrcerrs--;
            }
        }

        error_count++;
    }

    printf ("%d, %d\n", decode_matrix_count, decode_list_count);

out:
    return err;
}

int main(void)
{
    printf ("%d\n", (sizeof(ec_decode_matrix_t) + 20 + 20 + 20 * sizeof(int) + 20 * 16 * 32 + 20 * 16) * 6195 / 1024/ 1024);
    /*printf ("%d, %d\n", 0, '0');*/
    ec_method_initialize_intel (20, 16);
    ec_method_decode_matrix_init (20, 16);
}
